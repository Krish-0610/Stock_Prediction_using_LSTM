<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Stock Prediction Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<!-- Date adapter for time scale -->
<script src="https://cdn.jsdelivr.net/npm/luxon@3.4.4/build/global/luxon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.3.1/dist/chartjs-adapter-luxon.umd.min.js"></script>
<style>
  body {
    font-family: Inter, system-ui, sans-serif;
    margin: 0;
    padding: 24px;
    background: #ffffff;
    color: #111111;
  }
  .container { max-width: 1100px; margin: 0 auto; animation: fadeIn 0.8s ease-in-out; }
  header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
  h1 { font-size: 22px; animation: slideDown 0.6s ease-in-out; }
  .pillbar { display: inline-flex; background: #fff; border: 1px solid #e2e2e2; border-radius: 999px; padding: 4px; }
  .pillbar button { border: none; background: transparent; padding: 8px 12px; cursor: pointer; border-radius: 999px; font-weight: 600; transition: all 0.3s ease; }
  .pillbar button.active { background: #000; color: #fff; transform: scale(1.05); }
  .pillbar button:hover { background: #00000010; }
  .card { background: #f7f7f7; border: 1px solid #e2e2e2; border-radius: 12px; padding: 16px; margin-bottom: 16px; box-shadow: 0 4px 10px rgba(0,0,0,0.05); transition: transform 0.3s ease, box-shadow 0.3s ease; }
  .card:hover { transform: translateY(-4px); box-shadow: 0 6px 14px rgba(0,0,0,0.1); }
  .grid { display: grid; grid-template-columns: 2fr 1fr; gap: 16px; }
  canvas { width: 100%; height: 360px; }
  .muted { color: #666; font-size: 14px; }
  .value { font-weight: 700; font-size: 24px; transition: all 0.3s ease; }
  .btn { border: 1px solid #ccc; border-radius: 8px; background: #fff; padding: 8px 14px; cursor: pointer; font-weight: 600; transition: background 0.3s ease, transform 0.2s ease; }
  .btn:hover { background: #000; color: #fff; transform: scale(1.03); }
  .btn:disabled { opacity: 0.6; cursor: not-allowed; }
  @keyframes fadeIn { from {opacity: 0;} to {opacity: 1;} }
  @keyframes slideDown { from {opacity: 0; transform: translateY(-20px);} to {opacity: 1; transform: translateY(0);} }
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>Stock Prediction Dashboard</h1>
    <div class="pillbar" id="periodBar">
      <button data-period="1d">1D</button>
      <button data-period="5d">5D</button>
      <button data-period="1m">1M</button>
      <button data-period="6m" class='active'>6M</button>
      <button data-period="1y">1Y</button>
    </div>
  </header>

  <div class="grid">
    <section class="card">
      <div class="muted">Interactive Price Chart</div>
      <canvas id="priceChart"></canvas>
      <div class="muted" id="chartStatus"></div>
    </section>

    <aside>
      <section class="card">
        <div class="muted">Predicted Open Price</div>
        <div class="value" id="predictedOpen">--</div>
      </section>
      <section class="card">
        <div class="muted">Predicted Close Price</div>
        <div class="value" id="predictedClose">--</div>
        <button class="btn" id="btnPredict">Generate New Prediction</button>
      </section>
      <section class="card">
        <div class="muted">Model Accuracy</div>
        <div class="muted" id="accuracy">--</div>
      </section>
    </aside>
  </div>
</div>

<script>
const state = { period: '1d', chart: null, lastClose: null, loading: false };
function fmt(v){return Number(v).toLocaleString(undefined,{maximumFractionDigits:2})}
function setStatus(msg){document.getElementById('chartStatus').textContent=msg||''}

function getOrCreateChart() {
  const canvas = document.getElementById('priceChart');
  // If a chart is already attached to this canvas, reuse it
  const existing = Chart.getChart(canvas);
  if (existing) return existing;
  const ctx = canvas.getContext('2d');
  return new Chart(ctx, {
    type: 'line',
    data: { labels: [], datasets: [
      { label: 'Open Price', data: [], borderColor: '#1e90ff', borderWidth: 2, pointRadius: 0, tension: 0.25, fill: false },
      { label: 'Close Price', data: [], borderColor: '#000000', borderWidth: 2, pointRadius: 0, tension: 0.25, fill: false }
    ]},
    options: {
      animation: { duration: 600, easing: 'easeOutQuart' },
      responsive: true,
      scales: {
        x: { type: 'time', time: { unit: 'day', tooltipFormat: 'MMM dd, yyyy' }, ticks: { color: '#555', autoSkip: true, maxRotation: 0 }, grid: { color: '#ececec' } },
        y: { ticks: { color: '#555', callback: v => '₹' + Number(v).toLocaleString() }, grid: { color: '#f0f0f0' } }
      },
      plugins: { legend: { labels: { color: '#333' } }, tooltip: { mode: 'index', intersect: false, callbacks: { label: ctx => `${ctx.dataset.label}: ₹${fmt(ctx.parsed.y)}` } } }
    }
  });
}

function renderChart(rows) {
  if (!rows || !rows.length) { setStatus('No chart data found'); return; }
  const labels = rows.map(r => new Date(r.Date));
  const openValues = rows.map(r => r.Open);
  const closeValues = rows.map(r => r.Close);

  // Always get or create without forcing a new instance
  state.chart = getOrCreateChart();
  state.chart.data.labels = labels;
  state.chart.data.datasets[0].data = openValues;
  state.chart.data.datasets[1].data = closeValues;
  state.chart.update();

  state.lastClose = closeValues.at(-1);
  setStatus('');
}

async function loadChart(){
  if (state.loading) return; // prevent overlap
  state.loading = true;
  setStatus('Loading...');
  try{
    const res = await fetch(`/api/chart/${state.period}/`, { cache: 'no-store' });
    if (!res.ok) throw new Error('Chart API failed');
    const data = await res.json();
    renderChart(data);
  }catch(e){ console.error(e); setStatus('Error loading chart'); }
  finally{ state.loading = false; setStatus(''); }

  setStatus('Loading...');
  try{
    const res = await fetch(`/api/chart/${state.period}/`,{cache:'no-store'});
    const data = await res.json();
    renderChart(data);
  }catch(e){setStatus('Error loading chart')}
  finally{setStatus('')}
}

async function loadPrediction(){
  setStatus('Predicting...');
  try{
    const res = await fetch('/api/predict/');
    const data = await res.json();
    const open = document.getElementById('predictedOpen');
    const close = document.getElementById('predictedClose');
    open.style.transform = 'scale(1.1)'; close.style.transform = 'scale(1.1)';
    open.textContent = '₹'+fmt(data.predicted_open||0);
    close.textContent = '₹'+fmt(data.predicted_close||0);
    setTimeout(()=>{open.style.transform='scale(1)'; close.style.transform='scale(1)';},400);
  }catch(e){setStatus('Prediction failed')}
  finally{setStatus('')}
}

async function loadEvaluation(){
  try{
    const res = await fetch('/api/evaluate/');
    const data = await res.json();
    const open = (data.r2_score_open*100).toFixed(2);
    const close = (data.r2_score_close*100).toFixed(2);
    const el = document.getElementById('accuracy');
    el.style.opacity='0';
    setTimeout(()=>{el.innerHTML = `<b> Open: ${open}%, Close: ${close}% </b>`; el.style.opacity='1';},200);
  }catch{}
}

async function refreshAll(){
  await loadChart();
  await loadPrediction();
  await loadEvaluation();
}

document.getElementById('periodBar').addEventListener('click',e=>{
  const btn = e.target.closest('button[data-period]');
  if(!btn)return;
  document.querySelectorAll('#periodBar button').forEach(b=>b.classList.remove('active'));
  btn.classList.add('active');
  state.period = btn.dataset.period;
  refreshAll();
});

document.getElementById('btnPredict').addEventListener('click',loadPrediction);
window.addEventListener('DOMContentLoaded',refreshAll);
</script>
</body>
</html>
